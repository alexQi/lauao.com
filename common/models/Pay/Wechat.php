<?php
namespace common\models\Pay;
use yii;
use common\models\Pay\Wechat\JsApiPay;
use common\models\Pay\Wechat\WxPayApi;
use common\models\Pay\Wechat\WxPayException;
use common\models\Pay\Wechat\WxPayNotifyReply;
use common\models\Pay\Wechat\WxPayResults;
use common\models\Pay\Wechat\WxPayUnifiedOrder;
use yii\base\Event;
use yii\web\HttpException;

/**
 * 微信支付
 * Class Wechat
 * @package app\models\Pay
 */
class Wechat extends \callmez\wechat\sdk\Wechat
{
    public $redis;
    public function init()
    {
        $this->redis = yii::$app->redis;
        parent::init(); // TODO: Change the autogenerated stub
    }

    /**
     * 通知回调地址
     * @var
     */
    public $notfy_url;

    //=======【证书路径设置】=====================================
    /**
     * TODO：设置商户证书路径
     * 证书路径,注意应该填写绝对路径（仅退款、撤销订单时需要，可登录商户平台下载，
     * API证书下载地址：https://pay.weixin.qq.com/index.php/account/api_cert，下载之前需要安装商户操作证书）
     * @var path
     */
    public $sslcert_path = '../cert/apiclient_cert.pem';
    public $sslkey_path = '../cert/apiclient_key.pem';

    //=======【上报信息配置】===================================
    /**
     * TODO：接口调用上报等级，默认紧错误上报（注意：上报超时间为【1s】，上报无论成败【永不抛出异常】，
     * 不会影响接口调用流程），开启上报之后，方便微信监控请求调用的质量，建议至少
     * 开启错误上报。
     * 上报等级，0.关闭上报; 1.仅错误出错上报; 2.全量上报
     * @var int
     */
    public $report_levenl = 1;

    //=======【curl代理设置】===================================
    /**
     * TODO：这里设置代理机器，只有需要代理的时候才设置，不需要代理，请设置为0.0.0.0和0
     * 本例程通过curl使用HTTP POST方法，此处可修改代理服务器，
     * 默认CURL_PROXY_HOST=0.0.0.0和CURL_PROXY_PORT=0，此时不开启代理（如有需要才设置）
     * @var unknown_type
     */
    public $curl_proxy_host = "0.0.0.0";//"10.152.18.220";
    public $curl_proxy_port = 0;//8080;

    /**
     * 永久媒体文件上传
     */
    const WECHAT_MATERIAL_ADD_URL = 'https://api.weixin.qq.com/cgi-bin/material/add_material?';
    /**
     * 永久媒体文件获取
     */
    const WECHAT_MATERIAL_GET_URL = 'https://api.weixin.qq.com/cgi-bin/material/get_material?';
    /**
     * 永久媒体文件删除
     */
    const WECHAT_MATERIAL_DEL_URL = 'https://api.weixin.qq.com/cgi-bin/material/del_material?';
    /**
     * 媒体文件获取
     */
    const WECHAT_MEDIA_GET_URL = 'https://api.weixin.qq.com/cgi-bin/media/get?';

    /**
     * 获取AccessToken
     * @param bool $force
     * @return string
     * @throws \yii\web\HttpException
     */
    public function getAccessToken($force = false){
        $redis = \Yii::$app->redis;
        $atk = 'access_token_'.$this->appId;
        $nnat = 'net_new_access_token_'.$this->appId;
        if ($this->_accessToken === null || $this->_accessToken['expire'] < YII_BEGIN_TIME || $force) {
            $result = !$force && $this->_accessToken === null ? json_decode($redis->get($atk),true) : false;
            if ($result === false) {
                if (!($result = $this->requestAccessToken())) {
                    throw new HttpException(500, 'Fail to get access_token from wechat server.');
                }
                $this->trigger(self::EVENT_AFTER_ACCESS_TOKEN_UPDATE, new Event(['data' => $result]));
                $redis->set($atk,json_encode($result));
            }
            if(is_array($result)){
                $this->setAccessToken($result);
            }else{
                self::getAccessToken(true);
            }
        }
        $redis->set($nnat,$this->_accessToken['token']);
        return $this->_accessToken['token'];
    }

    /**
     * 获取jsapi_ticket
     * 会自动判断超时时间然后重新获取新的ticket
     * (会智能缓存jsApiTicket)
     * @param bool $force
     * @return mixed
     * @throws HttpException
     */
    public function getJsApiTicket($force = false)
    {
        if ($this->_jsApiTicket === null || $this->_jsApiTicket['expire'] < YII_BEGIN_TIME || $force) {
            $result = !$force && $this->_jsApiTicket === null ? $this->getCache('js_api_ticket', false) : false;
            if ($result === false) {
                if (!($result = $this->requestJsApiTicket())) {
                    if (!($result = $this->requestJsApiTicket('jsapi',true))) {
                        throw new HttpException(500, 'Fail to get jsapi_ticket from wechat server.');
                    }
                }
                $this->trigger(self::EVENT_AFTER_JS_API_TICKET_UPDATE, new Event(['data' => $result]));
                $this->setCache('js_api_ticket', $result, $result['expires_in']);
            }
            $this->setJsApiTicket($result);
        }
        return $this->_jsApiTicket['ticket'];
    }

    /**
     * 请求服务器jsapi_ticket
     * @param string $type
     * @return array
     */
    protected function requestJsApiTicket($type = 'jsapi',$force = false)
    {
        $result = $this->httpGet(static::WECHAT_JS_API_TICKET_URL, [
            'access_token' => $this->getAccessToken($force),
            'type' => $type
        ]);
        if (isset($result['ticket'])) {
            $result['expire'] = $result['expires_in'] + (int)YII_BEGIN_TIME;
            return $result;
        }
        return false;
    }

    /**
     * 生成js 必要的config
     * 只需在视图文件输出JS代码:
     *  wx.config(<?= json_encode($wehcat->jsApiConfig()) ?>); // 默认全权限
     *  wx.config(<?= json_encode($wehcat->jsApiConfig([ // 只允许使用分享到朋友圈功能
     *      'jsApiList' => [
     *          'onMenuShareTimeline'
     *      ]
     *  ])) ?>);
     * @param array $config
     * @param bool $debug
     * @return array
     * @throws HttpException
     */
    public function jsApiConfig(array $config = [], $debug = true)
    {
        $data = [
            'jsapi_ticket' => $this->getJsApiTicket(),
            'noncestr' => \Yii::$app->getSecurity()->generateRandomString(16),
            'timestamp' => (int)YII_BEGIN_TIME,
            'url' => explode('#', \Yii::$app->getRequest()->getAbsoluteUrl())[0]
        ];

        return array_merge([
            'debug' => $debug,
            'appId' => $this->appId,
            'timestamp' => $data['timestamp'],
            'nonceStr' => $data['noncestr'],
            'signature' => sha1(urldecode(http_build_query($data))),
            'jsApiList' => [
                'checkJsApi',
                'onMenuShareTimeline',
                'onMenuShareAppMessage',
                'onMenuShareQQ',
                'onMenuShareWeibo',
                'hideMenuItems',
                'showMenuItems',
                'hideAllNonBaseMenuItem',
                'showAllNonBaseMenuItem',
                'translateVoice',
                'startRecord',
                'stopRecord',
                'onRecordEnd',
                'playVoice',
                'pauseVoice',
                'stopVoice',
                'uploadVoice',
                'downloadVoice',
                'chooseImage',
                'previewImage',
                'uploadImage',
                'downloadImage',
                'getNetworkType',
                'openLocation',
                'getLocation',
                'hideOptionMenu',
                'showOptionMenu',
                'closeWindow',
                'scanQRCode',
                'chooseWXPay',
                'openProductSpecificView',
                'addCard',
                'chooseCard',
                'openCard'
            ]
        ], $config);
    }

    /**
     * 设置订单金额，字符金额 以 分为单位 比如 10 元， 应写成 1000	(10)
     * @param $orderAmount
     */
    public function getOrderAmount($orderAmount){
        $price = (float)$orderAmount*100;
        return $price.'';
    }

    /**
     * 统一下单获取支付参数
     * @param string $out_trade_no     订单号
     * @param int $total_fee        支付金额
     * @param string $notify_url       通知回调地址
     * @param string $body             订单描述
     * @param string $attach           订单附加属性
     * @param string $goods_tag        商品标签
     * @return string Wechat\json数据
     * @throws WxPayException
     */
    public function unifiedOrder($out_trade_no,$total_fee,$notify_url,$body = '',$attach = '',$goods_tag = '',$code_url = ''){
        //①、获取用户openid
        $tools = new JsApiPay();
        $openId = $tools->GetOpenid($code_url);
        //②、统一下单
        $input = new WxPayUnifiedOrder();
        $input->SetBody($body);
        $input->SetAttach($attach);
        $input->SetOut_trade_no($out_trade_no);
        $input->SetTotal_fee(self::getOrderAmount($total_fee));
        $input->SetTime_start(date("YmdHis"));
        $input->SetTime_expire(date("YmdHis", time() + 600));
        $input->SetGoods_tag($goods_tag);
        $input->SetNotify_url($notify_url);
        $input->SetTrade_type("JSAPI");
        $input->SetOpenid($openId);
        $order = WxPayApi::unifiedOrder($input);
        $jsApiParameters = $tools->GetJsApiParameters($order);
        ApiService::pay_log("微信支付参数",$jsApiParameters,$out_trade_no,'wxpay');
        return $jsApiParameters;
    }

    /**
     * 获取共享收货地址js函数参数
     * @return $res 获取共享收货地址js函数需要的参数
     */
    public function addressParameters(){
        $tools = new JsApiPay();
        //获取共享收货地址js函数参数
        $res = $tools->GetEditAddressParameters();

        return $res;
    }

    /**
     * 获取通知数据
     * @return array|bool
     */
    public function notifyData($plat=1){
        //获取通知的数据
//        $xml = $GLOBALS['HTTP_RAW_POST_DATA'];
        $xml = file_get_contents("php://input"); //使用新的方式获取数据，旧方式已于php7.0淘汰
        //如果返回成功则验证签名
        try {
            $result = WxPayResults::Init($xml,$plat);
        } catch (WxPayException $e){
            \Yii::error($e->errorMessage(),'wechat.text');
            return false;
        }
        return $result;
    }

    /**
     * 通知微信
     * @param bool $status      通知状态
     * @param bool $needSign    是否需要签名
     * @throws WxPayException
     */
    public function notifyMsg($status,$needSign = true){
        $msg = "OK";
        $notify = new WxPayNotifyReply();
        if($status == false){
            $notify->SetReturn_code("FAIL");
            $notify->SetReturn_msg($msg);
            $needSign = false;
        } else {
            //该分支在成功回调到NotifyCallBack方法，处理完成之后流程
            $notify->SetReturn_code("SUCCESS");
            $notify->SetReturn_msg("OK");
        }
        //如果需要签名
        if($needSign == true &&
            $notify->GetReturn_code() == "SUCCESS")
        {
            $notify->SetSign();
        }
        WxPayApi::replyNotify($notify->ToXml());
    }
}
